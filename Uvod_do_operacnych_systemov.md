# üß† Procesy a Pipe v operaƒçnom syst√©me

Tento dokument vysvetƒæuje princ√≠py **procesov, PCB, forku, wait()** a **pipe** v operaƒçnom syst√©me. Obsahuje texty a diagramy form√°tovan√© ako bloky k√≥du pre zachovanie ≈°trukt√∫ry.

---

## üß© Proces : be≈æiaca in≈°tanca programu v operaƒçnom syst√©me 

≈°trukt√∫ra procesu 

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      PROCES V PAM√ÑTI            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  TEXT SEGMENT                   ‚îÇ  ‚Üê Strojov√Ω k√≥d programu (read-only)
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  DATA SEGMENT                   ‚îÇ  ‚Üê Glob√°lne a statick√© premenn√©
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  HEAP                           ‚îÇ  ‚Üê Dynamick√° pam√§≈• (malloc, new)
‚îÇ         ‚Üì rastie nadol          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ         ‚Üë rastie nahor          ‚îÇ
‚îÇ  STACK                          ‚îÇ  ‚Üê Lok√°lne premenn√©, n√°vratov√© adresy
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  KERNEL SPACE                   ‚îÇ  ‚Üê D√°ta jadra OS (nedostupn√© u≈æ√≠vateƒæovi)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### üåÄ Stavov√Ω diagram procesu v niekolkych stavoch 


```text
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ    NEW      ‚îÇ  ‚Üê Proces sa pr√°ve vytv√°ra
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ   READY     ‚îÇ  ‚Üê ƒåak√° na CPU
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚Üì
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ  RUNNING    ‚îÇ  ‚Üê Vykon√°va sa na CPU
    ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò
       ‚îÇ   ‚îÇ   ‚îÇ
       ‚Üì   ‚Üì   ‚Üì
   WAITING READY TERMINATED
```


```text
   Proces control block == PCb
```

```text
   OS udr≈æuje pre kazdy proces pcb ≈°trukturu ktor√Ω vyzer√° takto : struct PCB {
```

```text
    pid_t pid;                   Process ID
    pid_t ppid;                  Parent PID
    int state;                   READY, RUNNING, WAITING...
    int priority;                Priorita pl√°novania
    void* program_counter;       Kde sa vykon√°va k√≥d
    void* stack_pointer;         Vrchol z√°sobn√≠ka
    void* registers[N];          Hodnoty registrov CPU
    FileDescriptor* fd_table;    Otvoren√© s√∫bory
    MemoryMap* memory;           Mapa pam√§te
    // ... ƒèal≈°ie √∫daje
```
};


Ka≈æd√Ω proces m√° svoj PCB

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   RODIƒå PCB     ‚îÇ
‚îÇ   PID:  1000    ‚îÇ ‚Üê Jeho jedineƒçn√© ID
‚îÇ   PPID: 999     ‚îÇ ‚Üê ID jeho rodiƒça
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

2. Po fork() vznikne k√≥pia s vlastn√Ωm PCB

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  POTOMOK PCB    ‚îÇ
‚îÇ   PID:  1001    ‚îÇ ‚Üê NOV√â jedineƒçn√© ID
‚îÇ   PPID: 1000    ‚îÇ ‚Üê ID rodiƒça (z ktor√©ho vznikol)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            POTOMOK PCB                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ PID:  1001      ‚Üê Jeho ID v syst√©me     ‚îÇ
‚îÇ PPID: 1000      ‚Üê ID rodiƒça             ‚îÇ
‚îÇ state: RUNNING                          ‚îÇ
‚îÇ registers: [...]                        ‚îÇ
‚îÇ memory_map: 0x3000-0x4000               ‚îÇ
‚îÇ file_descriptors: [0, 1, 2, 3, ...]     ‚îÇ
‚îÇ ... atƒè ...                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üë
   POZOR V PCB NIE JE ≈æiadna "0"!
```

Kde teda je t√° "0"?

T√° "0" je v pam√§ti procesu, nie v PCB!

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         USER SPACE PAM√Ñ≈§ POTOMKA                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  int main() {                                    ‚îÇ
‚îÇ      pid_t pid;        ‚Üê Premenn√° v pam√§ti       ‚îÇ
‚îÇ      pid = fork();     ‚Üê Tu sa ulo≈æ√≠ 0           ‚îÇ
‚îÇ                   ‚Üì                              ‚îÇ
‚îÇ      Premenn√° pid obsahuje: 0                    ‚îÇ
‚îÇ  }                                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Rozdiel medzi PCB a pam√§≈•ou procesu

KERNEL SPACE (spravuje OS):
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   PCB POTOMKA       ‚îÇ
‚îÇ   PID:  1001        ‚îÇ ‚Üê Toto je ID procesu
‚îÇ   PPID: 1000        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚Üë
    Nedostupn√© z k√≥du
```


USER SPACE (tvoj program):
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Pam√§≈• programu    ‚îÇ
‚îÇ                     ‚îÇ
‚îÇ   pid_t pid = 0;    ‚îÇ ‚Üê Premenn√°, ktor√∫ vytvoril fork()
‚îÇ                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚Üë
    M√¥≈æe≈° pristupova≈• z k√≥du
```

ƒåo sa stane pri for () ? 

## ‚öôÔ∏è ƒåo sa stane pri fork()()

Kernel vytvor√≠ nov√Ω PCB s PID 1001
Kernel nakop√≠ruje pam√§≈• rodiƒça do potomka
Kernel nastav√≠ n√°vratov√∫ hodnotu funkcie fork():

V rodiƒçovi: do registra CPU ulo≈æ√≠ 1001
V potomkovi: do registra CPU ulo≈æ√≠ 0


Keƒè sa proces vr√°ti z fork(), ulo≈æ√≠ hodnotu z registra do premennej pid

### üß¨ Anal√≥gia 

RODIƒå:
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ M√¥j dom: 1000   ‚îÇ ‚Üê M√¥j PID
‚îÇ Syn b√Ωva: 1001  ‚îÇ ‚Üê Premenn√° pid (adresa syna)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

POTOMOK:
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ M√¥j dom: 1001   ‚îÇ ‚Üê M√¥j PID
‚îÇ Som syn: 0      ‚îÇ ‚Üê Premenn√° pid (sign√°l "som syn")
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```





KERNEL rob√≠ toto:

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   fork() vn√∫torne:   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1. Vytvor nov√Ω PCB   ‚îÇ
‚îÇ 2. Priraƒè nov√Ω PID   ‚îÇ  ‚Üí Potomok dostane napr. PID 1001
‚îÇ 3. Skop√≠ruj pam√§≈•    ‚îÇ
‚îÇ 4. V RODIƒåOVI:       ‚îÇ
‚îÇ    return 1001;      ‚îÇ  ‚Üê Vr√°ti PID potomka
‚îÇ 5. V POTOMKOVI:      ‚îÇ
‚îÇ    return 0;         ‚îÇ  ‚Üê Vr√°ti 0
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     RODIƒå                   ‚îÇ     ‚îÇ     POTOMOK                 ‚îÇ
‚îÇ     PID = 1000              ‚îÇ     ‚îÇ     PID = 1001              ‚îÇ
‚îÇ                             ‚îÇ     ‚îÇ                             ‚îÇ
‚îÇ  int main() {               ‚îÇ     ‚îÇ  int main() {               ‚îÇ
‚îÇ      pid_t pid;             ‚îÇ     ‚îÇ      pid_t pid;             ‚îÇ
‚îÇ      pid = fork();          ‚îÇ     ‚îÇ      pid = fork();          ‚îÇ
‚îÇ         ‚Üì                   ‚îÇ     ‚îÇ         ‚Üì                   ‚îÇ
‚îÇ      pid = 1001  ‚Üê !!!!     ‚îÇ     ‚îÇ      pid = 0     ‚Üê !!!!     ‚îÇ
‚îÇ                             ‚îÇ     ‚îÇ                             ‚îÇ
‚îÇ      if (pid == 0) {        ‚îÇ     ‚îÇ      if (pid == 0) {        ‚îÇ
‚îÇ         // FALSE            ‚îÇ     ‚îÇ         // TRUE ‚Üê ide sem   ‚îÇ
‚îÇ      } else {               ‚îÇ     ‚îÇ      }                      ‚îÇ
‚îÇ         // TRUE ‚Üê ide sem   ‚îÇ     ‚îÇ                             ‚îÇ
‚îÇ      }                      ‚îÇ     ‚îÇ                             ‚îÇ
‚îÇ  }                          ‚îÇ     ‚îÇ  }                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```


Vizualiz√°cia cel√©ho procesu


PRED fork():
```text
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
```
RODIƒå (PID 1000):
  PCB: { PID: 1000, PPID: 999, ... }
  Pam√§≈•: { int main() { pid_t pid; ... } }


PO fork():
```text
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
```
RODIƒå (PID 1000):
  PCB: { PID: 1000, PPID: 999, ... }
  Pam√§≈•: { pid = 1001; }  ‚Üê n√°vratov√° hodnota fork()
```text
           ‚Üë
       Ulo≈æen√° v USER SPACE!
```

POTOMOK (PID 1001):
  PCB: { PID: 1001, PPID: 1000, ... }
  Pam√§≈•: { pid = 0; }  ‚Üê n√°vratov√° hodnota fork()
```text
           ‚Üë
       Ulo≈æen√° v USER SPACE!
```


### ‚ùì Kde sa nach√°dza hodnota 0 ? 

v premennej pid v user space pamati nie v pcb 

pcb obsahuje pid 1001 - skutoƒçn√© id procesu

premenn√° pid v kode obsahuje 0 navratova hodnota fork 

getpid() --> ƒç√≠ta z PCB ---> vracia 1001

Ak√Ω je call pri volan√≠ fork ? 

1. Zavol√°≈° fork()
```text
   ‚Üì
```
2. Kernel vytvor√≠ k√≥piu procesu (nov√Ω PCB s nov√Ωm PID)
```text
   ‚Üì
```
3. Kernel VEDOME nastav√≠ n√°vratov√∫ hodnotu fork():
```text
   - V rodiƒçovi: vr√°ti PID potomka (napr. 1001) == preƒço ? bez pid by rodiƒç nevedel na koho ƒçak√° u wait toto≈æne tak pre signaly napr kill , pre sledovanie potomkov 
   - V potomkovi: vr√°ti 0
   ‚Üì
```
4. T√°to n√°vratov√° hodnota sa ulo≈æ√≠ do premennej:
```text
   pid_t pid = fork();
```

```text
   Ako to rob√≠ kernel ? 
```

Pseudok√≥d toho, ƒço kernel rob√≠ vn√∫torne:

void kernel_fork() {

```text
    // 1. Vytvor nov√Ω PCB
    PCB* child = create_new_process();
    child->pid = 1001;
    child->ppid = current_process->pid;
```
    
```text
    // 2. Skop√≠ruj pam√§≈•
    copy_memory(current_process, child);
```
    
```text
    // 3. KRITICK√â: Nastav n√°vratov√© hodnoty
    current_process->return_value = child->pid;   Rodiƒç dostane 1001
    child->return_value = 0;                      Potomok dostane 0
```
    
```text
    // 4. Obaja procesy sa teraz prebudia z fork()
```


```text
    0 teda hovor√≠ nemam ziadnych vlastnych potomkov 
```
}

## ‚è≥ Funkcia wait() 


= rodiƒç musi poƒçka≈• na ukonƒçenie potomka 

= wait ƒçak√° na ak√©hokoƒævek potomka 



## ‚è≥ Funkcia wait()pid 

poƒçk√° len na toho jedn√©ho 


Kernel si pam√§t√° vz≈•ahy rodiƒç poto

ƒço sa deje ? 

RODIƒå vol√° wait():
```text
‚îÇ
‚îú‚îÄ> Kernel: "Hƒæad√°m potomkov s PPID = 1000"
‚îÇ
‚îú‚îÄ> Na≈°iel som: PID 1001 (PPID = 1000)
‚îÇ   Je zombie? NIE, e≈°te be≈æ√≠
‚îÇ
‚îú‚îÄ> Na≈°iel som: PID 1002 (PPID = 1000)  
‚îÇ   Je zombie? NIE, e≈°te be≈æ√≠
‚îÇ
‚îú‚îÄ> ≈Ωiadny zombie ‚Üí Usp√≠m rodiƒça
‚îÇ
‚îÇ   [ƒças plynie...]
‚îÇ
‚îú‚îÄ> PID 1001 vol√° exit(0)
‚îÇ   St√°va sa ZOMBIE
‚îÇ
‚îú‚îÄ> Kernel: "Zob√∫dzam rodiƒça s PID 1000"
‚îÇ   Vyƒçist√≠m zombie 1001
‚îÇ
‚îî‚îÄ> wait() vr√°ti: 1001
```

Praktick√Ω pr√≠klad : 

Jeden potomok ( nepotrebuje≈° PID )

int main() {
```text
    fork();   Nemus√≠≈° uklada≈• PID!
```
    
```text
    if (fork() == 0) {
        // POTOMOK
        printf("Potomok\n");
        exit(0);
    } else {
        // RODIƒå
        wait(NULL);   Kernel s√°m n√°jde potomka
        printf("Hotovo\n");
    }
```
}

Kernel vie, ≈æe tento proces m√° potomka (podƒæa PPID v tabuƒæke)
wait() poƒçk√° na toho potomka
Nemus√≠≈° ≈°pecifikova≈• PID

TABUƒΩKA PROCESOV (v kernel space):

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ PID  ‚îÇ PPID ‚îÇ STATE    ‚îÇ ...         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1    ‚îÇ 0    ‚îÇ RUNNING  ‚îÇ (init)      ‚îÇ
‚îÇ 999  ‚îÇ 1    ‚îÇ RUNNING  ‚îÇ             ‚îÇ
‚îÇ 1000 ‚îÇ 999  ‚îÇ WAITING  ‚îÇ ‚Üê RODIƒå     ‚îÇ
‚îÇ 1001 ‚îÇ 1000 ‚îÇ ZOMBIE   ‚îÇ ‚Üê POTOMOK   ‚îÇ
‚îÇ 1002 ‚îÇ 1000 ‚îÇ RUNNING  ‚îÇ ‚Üê POTOMOK   ‚îÇ
‚îÇ 1003 ‚îÇ 500  ‚îÇ RUNNING  ‚îÇ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üë
       PPID umo≈æ≈àuje kernelu n√°js≈•
       v≈°etk√Ωch potomkov rodiƒça
```

Ako to funguje v pozad√≠ vyhƒæad√°vania 

Process* find_children(pid_t parent_pid) {
```text
    // ‚Üë Vr√°ti ukazovateƒæ na Process (alebo pole procesov)
    //                    ‚Üë Parameter: PID rodiƒça
```
    
```text
    Process* children = [];
    // ‚Üë Pole ukazovateƒæov na procesy (potomkov)
```
    
```text
    for (each process in process_table) {
        // ‚Üë Iteruj cez V≈†ETKY procesy v syst√©me
        //   process_table = glob√°lna tabuƒæka v≈°etk√Ωch PCB
```
        
```text
        if (process.ppid == parent_pid) {
            // ‚Üë Ak PPID tohto procesu == parent_pid
            //   ‚Üí Tento proces JE potomok!
```
            
```text
            children.append(process);
            // ‚Üë Pridaj ho do zoznamu potomkov
        }
    }
```
    
```text
    return children;
    // ‚Üë Vr√°≈• pole v≈°etk√Ωch n√°jden√Ωch potomkov
```
}

## üßÆ Pipe (Roura) ‚Äì komunik√°cia medzi procesmi pre jednosmern√∫ komunik√°cou medzi procesmi 

Preƒço pipe existuje?

Probl√©m: Procesy s√∫ izolovan√©

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   PROCES A      ‚îÇ         ‚îÇ   PROCES B      ‚îÇ
‚îÇ   PID: 1000     ‚îÇ    ?    ‚îÇ   PID: 1001     ‚îÇ
‚îÇ   Pam√§≈•: 0x1000 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄX‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   Pam√§≈•: 0x3000 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Ka≈æd√Ω proces m√° vlastn√∫ pam√§≈•. Proces A nem√¥≈æe priamo ƒç√≠ta≈• pam√§≈• procesu B.

Rie≈°enie: Pipe cez kernel

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   PROCES A      ‚îÇ                     ‚îÇ   PROCES B      ‚îÇ
‚îÇ   write(fd, ..) ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ   read(fd, ..)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ         ‚îÇ      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚Üì         ‚Üì
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ  KERNEL SPACE    ‚îÇ
                  ‚îÇ                  ‚îÇ
                  ‚îÇ  PIPE BUFFER     ‚îÇ
                  ‚îÇ  [D√ÅTA D√ÅTA]     ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```


Kernel poskytuje zdieƒæan√Ω buffer, kde:

Proces A zapisuje d√°ta
Proces B ƒç√≠ta d√°ta
Kernel sa star√° o synchroniz√°ciu                  


Vytvorenie pipe 

#include <unistd.h>

int pipe(int pipefd[2]);

Parametre:

pipefd - pole 2 integerov (file descriptors)

Po √∫spe≈°nom volan√≠:

pipefd[0] = READ end (ƒç√≠tac√≠ koniec)
pipefd[1] = WRITE end (zapisovac√≠ koniec)

nacratova hodnota je 0 and -1 


PRED pipe():
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  FILE DESCRIPTOR TABLE           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 0  ‚îÇ stdin                       ‚îÇ
‚îÇ 1  ‚îÇ stdout                      ‚îÇ
‚îÇ 2  ‚îÇ stderr                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

PO pipe(pipefd):
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  FILE DESCRIPTOR TABLE                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 0  ‚îÇ stdin                                   ‚îÇ
‚îÇ 1  ‚îÇ stdout                                  ‚îÇ
‚îÇ 2  ‚îÇ stderr                                  ‚îÇ
‚îÇ 3  ‚îÇ PIPE READ end  ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îÇ
‚îÇ 4  ‚îÇ PIPE WRITE end ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ> [PIPE BUFFER]    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```


Kernel:

Vytvoril buffer v kernel space
Pridelil 2 file descriptors (napr. 3 a 4)
Jeden smeruje na ƒç√≠tac√≠ koniec, druh√Ω na zapisovac√≠

PIPE 

ƒåo je pipe a preƒço existuje?

Probl√©m: Procesy s√∫ izolovan√©

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   PROCES A      ‚îÇ    ?       ‚îÇ   PROCES B      ‚îÇ
‚îÇ   PID: 1000     ‚îÇ    X       ‚îÇ   PID: 1001     ‚îÇ
‚îÇ   int x = 42;   ‚îÇ nem√¥≈æe     ‚îÇ   int y;        ‚îÇ
‚îÇ   Pam√§≈•: 0x1000 ‚îÇ prist√∫pi≈•  ‚îÇ  Pam√§≈•: 0x3000  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Ka≈æd√Ω proces m√° vlastn√∫ pam√§≈•. Proces A nem√¥≈æe ƒç√≠ta≈• x z procesu B priamo.


```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   PROCES A      ‚îÇ                     ‚îÇ   PROCES B      ‚îÇ
‚îÇ                 ‚îÇ                     ‚îÇ                 ‚îÇ
‚îÇ  write(fd, ...) ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ  read(fd, ...)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ         ‚îÇ      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚Üì         ‚Üì
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ  KERNEL SPACE    ‚îÇ
                  ‚îÇ                  ‚îÇ
                  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
                  ‚îÇ  ‚îÇPIPE BUFFER ‚îÇ  ‚îÇ
                  ‚îÇ  ‚îÇ[D√ÅTA D√ÅTA] ‚îÇ  ‚îÇ
                  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Proces A zapisuje d√°ta 
Proces B ƒç√≠ta d√°ta 
Kernel synchronizuje                   


Anal√≥gia pre lep≈°ie pochopenie : 

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ KOH√öTIK  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ   R√öRA/POTRUBIE ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ  VEDRO   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```
  Nalieva≈°               Voda teƒçie              Vytek√°
```text
   vodu                  jedn√Ωm smerom            voda
```

Voda teƒçie len jedn√Ωm smerom ( jednosmern√° komunik√°cia )

Voda vych√°dza v rovnakom poradi FIFO - first in first out 

Syntax - vytvorenie pipe

#include <unistd.h>

int pipe(int pipefd[2]);

Parametre : 

```text
    pipefd - pole 2 integerov ( file descriptors )
```

Po √∫spe≈°nom volan√≠:

pipefd[0] = READ end (tzv ƒç√≠tac√≠ koniec)
pipefd[1] = WRITE end (zapisovac√≠ koniec)

N√°vratov√© hodnoty s√∫ teda 0 pre √∫spech, - 1 pre zlyhanie / chybu 

pr√≠klad vytvorenia : 

int pipefd[2];

if (pipe(pipefd) == -1) {
```text
    perror("pipe");
    exit(1);
```
}

printf("Pipe vytvoren√°!\n");
printf("pipefd[0] = %d (READ koniec)\n", pipefd[0]);    napr. 3
printf("pipefd[1] = %d (WRITE koniec)\n", pipefd[1]);   napr. 4

## üíæ File Descriptor (FD) (FD) 

File descriptor je mal√© cel√© ƒç√≠slo (integer), ktor√© reprezentuje otvoren√Ω "s√∫bor":

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Tvoj program (USER SPACE)             ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ  int fd = 3;                           ‚îÇ
‚îÇ      ‚Üì                                 ‚îÇ
‚îÇ  "M√°m l√≠stok ƒç√≠slo 3"                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  KERNEL                                ‚îÇ
‚îÇ                                        ‚îÇ
‚îÇ  FD 3 ‚Üí ukazuje na pipe read end      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

read(3, buffer, 100);

Kernel:

Pozrie sa: "FD 3? Aha, to je pipe read end"
Naƒç√≠ta d√°ta z pipe bufferu
Vr√°ti ich do tvojho buffer

≈†tandardn√© file descriptors
Ka≈æd√Ω proces m√° automaticky otvoren√©:

0 = stdin   (≈°tandardn√Ω vstup, kl√°vesnica)
1 = stdout  (≈°tandardn√Ω v√Ωstup, obrazovka)
2 = stderr  (chybov√Ω v√Ωstup, obrazovka)

ƒåo sa stane pri pipe() vn√∫torne?

PRED pipe():

PROCES:
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  FILE DESCRIPTOR TABLE           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 0  ‚îÇ stdin                       ‚îÇ
‚îÇ 1  ‚îÇ stdout                      ‚îÇ
‚îÇ 2  ‚îÇ stderr                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

PROCES:
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  FILE DESCRIPTOR TABLE                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 0  ‚îÇ stdin                                   ‚îÇ
‚îÇ 1  ‚îÇ stdout                                  ‚îÇ
‚îÇ 2  ‚îÇ stderr                                  ‚îÇ
‚îÇ 3  ‚îÇ PIPE READ end  ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îÇ
‚îÇ 4  ‚îÇ PIPE WRITE end ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚îò
                           ‚îÇ
                           ‚Üì
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ KERNEL SPACE ‚îÇ
                    ‚îÇ              ‚îÇ
                    ‚îÇ PIPE BUFFER  ‚îÇ
                    ‚îÇ  [........]  ‚îÇ
                    ‚îÇ   64 KB max  ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```


Kernel:

Vytvoril buffer v kernel space (~64 KB)
Pridelil 2 file descriptors (3 a 4)
FD 3 ‚Üí ƒç√≠tac√≠ koniec bufferu
FD 4 ‚Üí zapisovac√≠ koniec bufferu

Vn√∫torn√° ≈°trukt√∫ra pipe

USER SPACE:                  KERNEL SPACE:
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ pipefd[0]=3 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ  READ ENDPOINT           ‚îÇ
‚îÇ             ‚îÇ             ‚îÇ         ‚Üì                ‚îÇ
‚îÇ             ‚îÇ             ‚îÇ    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ             ‚îÇ             ‚îÇ    ‚îÇ  BUFFER  ‚îÇ          ‚îÇ
‚îÇ             ‚îÇ             ‚îÇ    ‚îÇ (FIFO)   ‚îÇ          ‚îÇ
‚îÇ             ‚îÇ             ‚îÇ    ‚îÇ ~64 KB   ‚îÇ          ‚îÇ
‚îÇ             ‚îÇ             ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îÇ             ‚îÇ             ‚îÇ         ‚Üë                ‚îÇ
‚îÇ pipefd[1]=4 ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ  WRITE ENDPOINT          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```


Buffer vlastnosti:

Veƒækos≈•: ~64 KB (65536 bytov)
Typ: FIFO (First In, First Out) - fronta
Umiestnenie: Kernel space (nedostupn√Ω priamo z programu)
Atomick√© oper√°cie (kernel zabezpeƒçuje synchroniz√°ciu)

## üîÑ Z√°kladn√° komunik√°cia ‚Äì Pr√≠klad - Jednoduch√Ω pr√≠klad

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main() {
```text
    int pipefd[2];
```
    
```text
    // 1. Vytvor pipe
    if (pipe(pipefd) == -1) {
        perror("pipe");
        exit(1);
    }
```
    
```text
    printf("Pipe vytvoren√°: READ=%d, WRITE=%d\n", 
           pipefd[0], pipefd[1]);
```
    
```text
    // 2. Fork - vytvor potomka
    pid_t pid = fork();
```
    
```text
    if (pid == 0) {
        // ===== POTOMOK - ƒåITATEƒΩ =====
        printf("[POTOMOK] Zatv√°r√°m write end\n");
        close(pipefd[1]);  // Nepotrebujem p√≠sanie
```
        
```text
        char buffer[100];
        printf("[POTOMOK] ƒåak√°m na d√°ta...\n");
        ssize_t n = read(pipefd[0], buffer, 100);
```
        
```text
        printf("[POTOMOK] Prijal som %zd bytov: %s\n", n, buffer);
```
        
```text
        close(pipefd[0]);
        exit(0);
```
        
```text
    } else {
        // ===== RODIƒå - ZAPISOVATEƒΩ =====
        printf("[RODIƒå] Zatv√°r√°m read end\n");
        close(pipefd[0]);  // Nepotrebujem ƒç√≠tanie
```
        
```text
        char msg[] = "Ahoj potomok!";
        printf("[RODIƒå] Posielam spr√°vu...\n");
        write(pipefd[1], msg, strlen(msg) + 1);
```
        
```text
        printf("[RODIƒå] Spr√°va odoslan√°\n");
        close(pipefd[1]);
```
        
```text
        wait(NULL);  // Poƒçkaj na potomka
        printf("[RODIƒå] Hotovo\n");
    }
```
    
```text
    return 0;
```
}


## ü™ú Kroky vykonania programu ? Krok po kroku 

Krok 1: pipe() v rodiƒçovi

RODIƒå:
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ pipefd[0] = 3 (READ)      ‚îÇ‚îÄ‚îÄ‚îê
‚îÇ pipefd[1] = 4 (WRITE)     ‚îÇ‚îÄ‚îÄ‚îº‚îÄ‚îÄ> [PIPE BUFFER: pr√°zdny]
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ---> 
```

Krok 2: fork()

RODIƒå:                          POTOMOK:
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ pipefd[0] = 3 (READ)      ‚îÇ  ‚îÇ pipefd[0] = 3 (READ)      ‚îÇ
‚îÇ pipefd[1] = 4 (WRITE)     ‚îÇ  ‚îÇ pipefd[1] = 4 (WRITE)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                              ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚Üì
                [PIPE BUFFER: pr√°zdny]
```

D√¥le≈æit√©: Obaja zdieƒæaj√∫ rovnak√Ω file descritptor smeruj√∫ce na rovnak√Ω pipe buffer!


Krok 3: Zatv√°ranie nepou≈æ√≠van√Ωch koncov


RODIƒå:                          POTOMOK:
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ close(pipefd[0]) ‚úó        ‚îÇ  ‚îÇ close(pipefd[1]) ‚úó        ‚îÇ
‚îÇ                           ‚îÇ  ‚îÇ                           ‚îÇ
‚îÇ pipefd[1] = 4 (WRITE) ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ>‚îÇ                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ pipefd[0] = 3 (READ) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                        ‚Üì
                                 [PIPE BUFFER]
```

Krok 4: Rodiƒç p√≠≈°e


RODIƒå:
write(4, "Ahoj potomok!", 14);

[PIPE BUFFER]:
```text
‚îå‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚î¨‚îÄ‚îÄ‚îê
‚îÇA‚îÇh‚îÇo‚îÇj‚îÇ ‚îÇp‚îÇo‚îÇt‚îÇo‚îÇm‚îÇo‚îÇk‚îÇ!‚îÇ\0‚îÇ
‚îî‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚î¥‚îÄ‚îÄ‚îò
```
 ‚Üë                            ‚Üë
 write                      14 bytov

Krok 5: Potomok ƒç√≠ta

 POTOMOK:
read(3, buffer, 100);

Buffer potomka:
"Ahoj potomok!\0"

[PIPE BUFFER]:
[pr√°zdny - d√°ta vyƒç√≠tan√©]


---

## üß© Celkov√° ≈°trukt√∫ra projektu


[Router 1 - Generuje data]
```text
          ‚Üì
```
[Router 2 - ƒå√≠sluje pakety]
```text
          ‚Üì
```
[Router 3 - Mƒõ≈ô√≠ d√©lku]
```text
          ‚Üì
```
[Router 4 - p≈ôevod na mal√° p√≠smena]  ‚Üê NOV√ù
```text
          ‚Üì
```
[Router 5 - p≈ôevod na velk√° p√≠smena] ‚Üê NOV√ù
```text
          ‚Üì
```
[Parent]

Kontrola funkcionality zadania   

./main data.txt 8

Overenie paralelneho behu 

Meranie ƒçasu ƒças je < 15 s keby bezali seriovo bolo by to >30 kvoli usleep 100000

time ./main data.txt 100 > /dev/null

Maliƒçka pozn√°mka : 

v√Ωstup tvojho programu sa ‚Äûprelieva‚Äú cez pipe do grepu, ktor√Ω preƒç√≠ta ka≈æd√Ω riadok zo ≈°tandardn√©ho vstupu a vyp√≠≈°e iba tie obsahuj√∫ce re≈•azec ‚Äûzpracoval‚Äú

./main data.txt 12 | grep -E "(SUD√Å|LICH√Å|R4|R5)"

Manualne overenie spravnosti routingu 

./main data.txt 12 | grep -E "(SUD√Å|LICH√Å|R4|R5)"

Parel√©lne spracovanie pre demon≈°tr√°ciu s√∫be≈ænosti 

./main data.txt 25

≈†tatistika a bilancia


./main data.txt 20  

podla dlzky parne neparne 

./main data.txt 15 | grep -E "(SUD√Å|LICH√Å)"

rozvetvit do dvoch paralelnych vetvi 

./main data.txt 20 | grep -E "(R4|R5)" | head -15

spracovanie textu odli≈°nym sposobom 

./main data.txt 10 | grep -E "(R4 \(VELK√Å\)|R5 \(mal√°\))"

opatovne spojenie v rod procese 

./main data.txt 15 | grep "P≈ôijat paket"

logovanie kolko paketov spracovala ktora vetva 

./main data.txt 50 | grep -E "(zpracoval|statistika)" -A2
